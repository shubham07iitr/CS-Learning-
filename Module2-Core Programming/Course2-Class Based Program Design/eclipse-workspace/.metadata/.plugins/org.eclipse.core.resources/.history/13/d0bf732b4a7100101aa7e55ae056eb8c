import tester.*;                // The tester library
import javalib.worldimages.*;   // images, like RectangleImage or OverlayImages
import javalib.funworld.*;      // the abstract World class and the big-bang library
import java.awt.Color;          // general colors (as triples of red,green,blue values)
import java.util.*;

//==================================================================================================== 
//Defining the final myworld class to run the game
//Will have the following fields, properties
//-- List of Bullets - to be initialised to MtList<Bullet>
//-- Missile - will be fixed and will be initialised to standard missile config: new Missile(new Posn (250, 475));
//--List of SpaceSihps - will be initialised to MtList to begin with 
//--Scoreboard - will be initialised to standard scoreboard config
//--Standard SS and Bullet to create new bullet and SS on screen 
//--noTicks - to count the no. of ticks on screen yet
class MyWorldFinal extends World{
	IList<Bullet> lob;
	Missile missile;
	IList<SpaceShip> loss;
	ScoreBoard sb;
	int bulletsRemaining;
	Bullet standardBullet;
	SpaceShip standardSpaceShip;
	int noTicks;

	MyWorldFinal(int bulletsRemaining) {
		this.lob = new MtList<Bullet>();
		this.missile  = new Missile(new Posn (250, 475));
		this.loss = new MtList<SpaceShip>();
		this.sb = new ScoreBoard(10, 0, new Posn(450, 25));
		this.bulletsRemaining = bulletsRemaining;
		this.standardBullet = new Bullet (20, new Posn (250,250));;
		this.standardSpaceShip = new SpaceShip(new Posn (50, 400), -1);
		this.noTicks = 0;
	}

	//TEMPLATE
	/*
	 * FIELDS
	 * ...this.lob.... IList <Bullets>
	 * ...this.missile ...Missile
	 * ...this.loss .... IList<SpaceShip>
	 * ...this.sb ..... ScoreBoard
	 * ...this.bulletsRemaining .....int
	 * METHODS
	 * ...this.makeScene   ..... WorldScene
	 * ...this.onTick..... MyWorld
	 * ...this.worldEnds ....MyWorld
	 * ...this.onTick .... MyWorld
	 * ...this.onMouseClicked ....MyWorld
	 * 
	 */

	//WRITING the STANDARD METHODS

	//METHOD MAKESCENE
	//This method will draw a scene on a world canvas
	//--Places all the elements in loss on screen
	//--Places all the elements in lob on screen
	//--Places the sb on screen
	//--Places the missile on screen 
	@Override
	public WorldScene makeScene() {return sb.place(missile.place(loss.placeAll(lob.placeAll(this.getEmptyScene()))));}

	//METHOD WORLDENDS
	//Determines when the gmae is over which is when the count f circles to go offscreen is 0 or less
	@Override
	public WorldEnd worldEnds(){
		if (this.bulletsRemaining == 0) {return new WorldEnd(true, this.getEmptyScene());}
		else {return new WorldEnd(false, this.makeScene());}
	}

	//METHOD onTICK
	//Will do the following with every tick:
	//-- generate a new spaceship every 3 ticks (either from left to right, or rtl, and with varied y and x positions and add to loss - helper method done
	//-- move the existing spaceships in left or right directions based on their xspeed and direction
	//-- move the exisiting bullets in list of bullets upwards based on velocity
	//--remove bullet from lob and reduce bullets remaining by 1 if it hits a spaceship from list of bullet
	//--remove bullet freom lob and reduce bullets remaining by 1 if bullet passes 0 on y axis
	//-- remove spaceship if it is hit by a bullet
	//-- remove spaceship from loss it it passes 500 on rhs or lhs based on direction
	@Override
	public MyWorldFinal onTick() {return this;}
	
	
	//METHOD onKEYEVENT
	//For every space bar press we would want to:
	//--add a new bullet to the list of bullets
	// decrease bullets remaining by 1
	@Override
	public MyWorldFinal onKeyEvent(String key) {
		this.lob = this.lob.addToList(standardBullet);
		return this;
	}

	
	//WRITING HELPER METHODS
	
	//METHOD ADDSS
	//Signature> Self > MyWorld
	//Returns a new MyWorld by adding a new spaceship to the loss
	//Randon values of x (0 or 500), if 0 then direction = 1, if 500, direction = -1, random value of y (between 50 to 450)
	
	public MyWorldFinal addSS() {
    int yCorRand = 50 + 25 * new Random().nextInt(17);
    int xCorRand = 500 * new Random().nextInt(2);
    int direction = (xCorRand == 0) ? 1 : -1;

    SpaceShip newSS = new SpaceShip(new Posn(xCorRand, yCorRand), direction);
    this.loss = this.loss.addToList(newSS);
    return this;
}
	
	//METHOD MOVELOSS
	//Signature>Self>MyWorld
	//Returns a new world where each f the spaceships in the loss has changed its coordinates by the xspeet
	
	public MyWorldFinal moveLoss {
		this.loss = this.moveLossHelper(this.loss); // we request for a helper function which changes the x and y cor for the ss by the xspeed and direction
		return this;
	}
	
	//METHOD MOVELOSSHELPER
	//will increement all the spaceships in the loss based on xspeed
	public IList<SpaceShip> moveLossHelper(IList<SpaceShip> los) {
		return new ConsList<SpaceShip> (new SpaceShip (new Posn(los.getFirst().pos.x + los.getFirst().direction*los.getFirst().xspeed, los.getFirst().pos.y), los.getFirst().direction), 
									this.moveLossHelper(los.getRest()));
	}
}





//================================================================================================

//CLASS EXAMPLESWORLDFINAL
class ExamplesWorldFinal {
	ExamplesWorldFinal() {}
	
	
	

}










