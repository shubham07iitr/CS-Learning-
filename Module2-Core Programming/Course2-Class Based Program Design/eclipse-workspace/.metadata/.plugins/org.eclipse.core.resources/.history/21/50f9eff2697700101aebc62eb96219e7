import tester.*;
import java.util.*;



//============================================================================================================
//ADJACENCY LIST REPRESENTATION

//CLASS VERTEX
//Each vertex will have name of vertex, and the list of edges from the vertext

class VertexA {
String name;

IList<EdgeA> listOfEdges ; //all edges emanating from the vertex

//Defining the Constructor
VertexA (String name, IList<EdgeA> listOfEdges) {this.name = name; this.listOfEdges = listOfEdges; }

//TEMPLATE
/*
 * FIELDS
 * ...this.listOfEdges ... IList<Edge>
 * METHODS
 * ...this.pathExistsVertex(Vertex v2) .... boolean
 */

//METHODS

//METHO PATHEXISTSVERTEX
//Returns true if path exists from this vertex to given vertex
//Signature> Self, Vertex v2 > boolean



//HELPER METHOD for PATHEXISTS
//We check for whether:
//-- there is a direct edge from v2 > v2
//-- or the first vertex is connected to v2
//-- or any of the ther vertices are connected to v2

}

//CLASS EDGE
//Edge is of type (From - Vertex, To - Vertex, Weight - Int)

class EdgeA {
VertexA from;
VertexA to;
int weight;

//Defining the constructor 
EdgeA (VertexA from, VertexA to, int weight) {this.from = from; this.to = to; this.weight = weight;}
}


//============================================================================================================
//CLASS GRAPHLIST
//It will be just a list of vertices

class GraphListA {
	IList<VertexA> listOfVertices;

	//Defining the constructor 
	GraphListA(IList<VertexA> listOfVertices) {this.listOfVertices = listOfVertices;}

	//TEMPLATE
	/*
	 * FIELDS
	 * ...this.listOfVertices.... IList<Vertex>
	 * METHODS
	 * ...this.pathExists(Vertex v1, Vertex v2) ... boolean
	 */


	//METHODS


	//METHOD PATHEXISTSDFS
	//Returns true if starting from a particular vertex, it is possible to reach to the destination vertex
	//We will need one accumulator for worklist, which all nodes we want to cover, and visited list, so lets use Deque
	//Will run through a stack where we go deep into a branch before backtracking
	//Signature> Vertex v1, Vertex v2 > boolean
	
	boolean pathExistsDFS (VertexA a, VertexA b) {
		Deque<VertexA> worklist = new ArrayDeque<VertexA>(); //we use Java's inbuilt interface for Deque, which has two implementations - ArrayDeque for arrays, and LinkedList() for recursion
		Deque<VertexA> visited = new ArrayDeque<VertexA>();

		worklist.addFirst(a); // we kick off by adding the from element in the worklist
		while (!worklist.isEmpty()) {
			VertexA next = worklist.removeFirst();  //we define the next element as the first element from the wrklist, next would be checked for destination, and its neighbors would be added to wrorklist
			if (next.equals(b)) {return true;} //we check wthere next element is same as the destination
			
			else {if (visited.contains(next)) {} //if the element is present in visited we do nothing
			
			else {IList<EdgeA> edges = next.listOfEdges; //if element is not present in visited, we add the neighbors to the worklist
			while (edges instanceof ConsList) {
				ConsList<EdgeA> cons = (ConsList<EdgeA>) edges;
				EdgeA e = cons.first;
				worklist.addFirst(e.to);
				edges = cons.rest;}
			visited.addFirst(next);}}} //and then we add eleemnt/next to the visited deque
		return false;}
	
	//METHOD PATHEXISTSBFS
	//Exactly same as DFS, instead we will add at the end from the deque 
	
	boolean pathExistsBFS (VertexA a, VertexA b) {
		Deque<VertexA> worklist = new ArrayDeque<VertexA>(); //we use Java's inbuilt interface for Deque, which has two implementations - ArrayDeque for arrays, and LinkedList() for recursion
		Deque<VertexA> visited = new ArrayDeque<VertexA>();

		worklist.addLast(a); // we kick off by adding the from element in the worklist
		while (!worklist.isEmpty()) {
			VertexA next = worklist.removeFirst();  //we define the next element as the first element from the wrklist, next would be checked for destination, and its neighbors would be added to wrorklist
			if (next.equals(b)) {return true;} //we check wthere next element is same as the destination
			
			else {if (visited.contains(next)) {} //if the element is present in visited we do nothing
			
			else {IList<EdgeA> edges = next.listOfEdges; //if element is not present in visited, we add the neighbors to the worklist
			while (edges instanceof ConsList) {
				ConsList<EdgeA> cons = (ConsList<EdgeA>) edges;
				EdgeA e = cons.first;
				worklist.addLast(e.to);
				edges = cons.rest;}
			visited.addFirst(next);}}} //and then we add eleemnt/next to the visited deque
		return false;}
	
	
	//METHOD SHORTESTPATH
	//We maintain a dictionary which will capture the parent node/or the shortest path from the from node to the to node
	//W/o weights shortest path would mean that we need to visit least no. of nodes to get to the destination
	//Signature> Vertex a, Vertex b > IList<Vertex>
	Deque<VertexA> shortestPath (VertexA a, VertexA b) {
		if (this.pathExistsBFS(a, b)) {return shortestPathHelper(a, b);} 
		else {return new ArrayDeque<VertexA> ();} } //we return an empty list in cases where no such path exist
	
	
	//METHOD SHORTESTPATHHELPER
	Deque<VertexA> shortestPathHelper (VertexA a, VertexA b) {
		Deque<VertexA> worklist = new ArrayDeque<VertexA>(); //we use Java's inbuilt interface for Deque, which has two implementations - ArrayDeque for arrays, and LinkedList() for recursion
		Deque<VertexA> visited = new ArrayDeque<VertexA>();
		Map<VertexA, VertexA> parentMap = new HashMap<>();
		
		worklist.addLast(a); // we kick off by adding the from element in the worklist
		while (!worklist.isEmpty()) {
			VertexA next = worklist.removeFirst();  //we define the next element as the first element from the wrklist, next would be checked for destination, and its neighbors would be added to wrorklist
			if (next.equals(b)) {return this.constructPath(parentMap, b, a);} //if we find a match then we call a helper method which will iterate over the hashmap to produce the result
			
			else {if (visited.contains(next)) {} //if the element is present in visited we do nothing
			
			else {IList<EdgeA> edges = next.listOfEdges; //if element is not present in visited, we add the neighbors to the worklist
			while (edges instanceof ConsList) {
				ConsList<EdgeA> cons = (ConsList<EdgeA>) edges;
				EdgeA e = cons.first;
				worklist.addLast(e.to);
				if (!parentMap.containsKey(e.to)) {parentMap.put(e.to, e.from);} //adding the parent node and child node here
				edges = cons.rest;}
			visited.addFirst(next);}}}
		return new ArrayDeque<VertexA>();} //and then we add eleemnt/next to the visited deque
		
	
	
	//METHOD CONSTRUCTPATH
	//Takes in a hashmap (parent and child) and a to vertex and a from vertex, and constructs a shortest path 
	//Signature> Map<VertexA, VertexA> , Vertex , Vertex > IList<Vertex>
	
	Deque<VertexA> constructPath (Map<VertexA, VertexA> dict, VertexA to, VertexA from) {
		Deque<VertexA> path = new ArrayDeque<VertexA>();
		VertexA endCounter 	= to;
		
		while (endCounter != from) {
			path.addFirst(endCounter);
			endCounter = dict.get(endCounter);}
		path.addFirst(endCounter);
		return path;}


}


//============================================================================================================
class ExamplesGraphAdvanced {
	ExamplesGraphAdvanced() {}
	
	//Graph defined as per this link -https://course.ccs.neu.edu/cs2510sp22/lecture30.html
	
	
	//Defining the vertices
	VertexA a = new VertexA("A", new MtList<EdgeA>());
	VertexA b = new VertexA("B", new MtList<EdgeA>());
	VertexA c = new VertexA("C", new MtList<EdgeA>());
	VertexA d = new VertexA("D", new MtList<EdgeA>());
	VertexA e = new VertexA("E", new MtList<EdgeA>());
	
	//Defining the Edges
	EdgeA ab = new EdgeA(a,b, 0);
	EdgeA bc = new EdgeA(b,c, 0);
	EdgeA bd = new EdgeA(b, d,0);
	EdgeA ca = new EdgeA(c,a, 0);
	EdgeA eb = new EdgeA(e, b, 0);
	
	//Defining list of edges 
	IList<EdgeA> aEdges = new ConsList<EdgeA>(ab, new MtList<EdgeA>());
	IList<EdgeA> bEdges = new ConsList<EdgeA>(bc, new ConsList<EdgeA> (bd, new MtList<EdgeA>()));
	IList<EdgeA> cEdges = new ConsList<EdgeA> (ca, new MtList<EdgeA>());
	IList<EdgeA> eEdges = new ConsList<EdgeA> (eb, new MtList<EdgeA>());
	
	//Defining the list of vertices
	IList<VertexA> listVertices = new ConsList<VertexA>(a, new ConsList<VertexA>(b, new ConsList<VertexA>(c, new ConsList<VertexA>(d, new ConsList<VertexA>(e,new MtList<VertexA>()))))); 
	
	//Defining the graph
	GraphListA newGraph = new GraphListA (listVertices);


//Updating the list of edges for vertices 
	void initConditions() {
		a.listOfEdges = aEdges;
		b.listOfEdges = bEdges;
		c.listOfEdges = cEdges;
		e.listOfEdges = eEdges;}
		
		
		
		//Testing the pathexists
		
	
	void testPathExists (Tester t) {
		this.initConditions();
		t.checkExpect(newGraph.pathExistsBFS(b, e), false);
		t.checkExpect(newGraph.pathExistsBFS(b, a), true);
		t.checkExpect(newGraph.pathExistsDFS(b, e), false);
		t.checkExpect(newGraph.pathExistsDFS(b, a), true);}
	
	//Testing for shortest path
	
	void testShortestPath (Tester t) {
		this.initConditions();
		t.checkExpect(newGraph.shortestPath(b, a), new ArrayDeque<VertexA>(Arrays.asList(b, c, a)));}
	
	
	
	
	

	
}






























