import tester.*;
import java.util.*;

//ICOMPARE Interface

interface ICompare<T> {
	int compare(T e1, T e2);}

class CompareInts implements ICompare<Integer> {
	public int compare (Integer e1, Integer e2) {return e1-e2;}
}


//===========================================================================
//UTILS CLASS

class Utils {
	Utils() {}
	
	
	//METHOD GETMIN
	//Will result in the minimum element in the array
	//Signature> Self, ArrayList<T>, ICompare<T> > T 
	<T> int getMinIndex(List<T> arr, ICompare<T> compareFunc) {
		if (arr.size()==0) {throw new RuntimeException("Can't get minimum for an empty arraylist.");}
		else  {return this.getMinIndexHelper(arr.subList(1, arr.size()) , compareFunc, 0, 0, arr.get(0));}}
	
	//METHOD GETMINHELPER
	<T> int getMinIndexHelper(List<T> arr, ICompare<T> compareFunc, int indexCounter, int smallestValueIndex, T smallestValue ) {
		if (arr.size() == 0) {return  smallestValueIndex;}
		else {if (compareFunc.compare(smallestValue, arr.get(0)) <= 0) {return this.getMinIndexHelper(arr.subList(1, arr.size()), compareFunc, indexCounter+1, smallestValueIndex, smallestValue);}
				 else {return this.getMinIndexHelper(arr.subList(1, arr.size()), compareFunc, indexCounter+1, indexCounter+1, arr.get(0));}}}
	
	
	//METHOD SWAP
	//Will swap two elements for the given index, will throw exception, if any of the index is out of bounds
	//Signature> Self, ArrayList<T>, int, int > Void
	<T> void swap(ArrayList<T> arr, int i1, int i2) {
		if (i1 >= arr.size() || i2 >= arr.size()) {throw new RuntimeException ("Given index is more than the length of the array");}
		else {
			T tempValue1 = arr.get(i1);
			T tempValue2 = arr.get(i2);
			arr.set(i2, tempValue1);
			arr.set(i1, tempValue2);}}
	
	//METHOD MERGE
	//Merges two sorted list in one single list and returns the merged list
	//Signature> Self, ArrayList<T> arr1, ArrayList<T> > ArrayList<T>
	<T> ArrayList<T> mergeLists(ArrayList<T> arr1, ArrayList<T> arr2, ICompare<T> compareFunc) {
		if (arr1.size() == 0) {return arr2;}
		else if (arr2.size()==0) {return arr1;}
		else {
			ArrayList<T> newArr1 = new ArrayList<T> (arr1.subList(1, arr1.size()));
			ArrayList<T> newArr2 = new ArrayList<T> (arr1.subList(1, arr2.size()));
			return this.insert(arr1.get(0), this.insert(arr2.get(0), this.mergeLists(newArr1, newArr2, compareFunc), compareFunc), compareFunc);}} //we wish for an insert function 
	
	//METHOD INSERT
	//Inserts an element T in the appropriate position in a sorted list and returns a new list
	//Signature> Self, T , ArrayList<T> > ArrayList<T>
	<T> ArrayList<T> insert (T elem, ArrayList<T> arr, ICompare<T> compareFunc) {
		int counter = 0;
		while (compareFunc.compare(elem, arr.get(counter)) >= 0) {
			counter = counter +1 ;}
		arr.add(counter, elem);
		return arr;
	}
	
	
	
	
	
	
	//METHOD SELECTIONSORT
	//Compares 1st element with the lowest element in the rest of the list, and swaps it and then recurses, returns the sorted list
	//Total iterations required > n-1 , where n is size of list
	//Signature> ArrayList<T> arr, ICompare<T> > Arr
	<T> ArrayList<T> selectionSort(ArrayList<T> arr, ICompare<T> compareFunc) {
		for (int i = 0 ; i < arr.size() -1; i++) {
			int minIndex = this.getMinIndex(arr.subList(i, arr.size()), compareFunc) + i;
			this.swap(arr, minIndex, i);}
		return arr;}}


//===========================================================================
//INSERTSEARCH ALGO

interface IListNew<T> {
	IListNew<T> sort(ICompare<T> compareFunc); //sorts the given list as per the comparator
	IListNew<T> insert(T element, ICompare<T> compareFunc); // adds a given element in a sorted list of elements
}

class MtListNew<T> implements IListNew<T> {
	//Defining the constructor
	MtListNew() {}
	
	public IListNew<T> sort(ICompare<T> compareFunc) {return this;} //sorting an empty list returns an empty list
	public IListNew<T> insert(T element, ICompare<T> compareFunc) {return new ConsListNew<T>(element, this);}
}

class ConsListNew<T> implements IListNew<T> {
	T first;
	IListNew<T> rest;
	
	//Defining the constructor
	ConsListNew(T first, IListNew<T> rest) {this.first = first; this.rest = rest;}
	
	//METHODS
	public IListNew<T> sort(ICompare<T> compareFunc) {
		return this.rest.sort(compareFunc).insert(this.first,compareFunc);} //inserts the given first element in a sorted list oof rest of elements
	
	public IListNew<T> insert(T element, ICompare<T> compareFunc) {
		if (compareFunc.compare(element, this.first) <= 0) {return new ConsListNew<T> (element, this);}
		else {return new ConsListNew<T>(this.first, this.rest.insert(element, compareFunc));}
	}

}



//===========================================================================
//TESTING SORTING ALGOS
//CLASS EXAMPLES

class ExamplesSort{
	ExamplesSort() {}
	
	//InsertSort TESTNG
	IListNew<Integer> insertListUnsorted = new ConsListNew<Integer> (3, new ConsListNew<Integer> (2, new ConsListNew<Integer>(1, new MtListNew<Integer>())));
	IListNew<Integer> insertListSorted = new ConsListNew<Integer> (1, new ConsListNew<Integer> (2, new ConsListNew<Integer>(3, new MtListNew<Integer>())));
	void testInsertSort(Tester t) {
		t.checkExpect(insertListUnsorted.sort(new CompareInts()), insertListSorted);}
	
	void testSelectionSort (Tester t) {
		ArrayList<Integer> selectionSortUnsorted = new ArrayList<Integer> (Arrays.asList(3,5,2,6,10));
		ArrayList<Integer> selectionSortSorted = new ArrayList<Integer> (Arrays.asList(2,3,5,6,10));
		Utils util = new Utils();
		t.checkExpect(util.selectionSort(selectionSortUnsorted, new CompareInts()), selectionSortSorted);}
	
	void testUtilsSwapAndGetMinIndex(Tester t) {
		ArrayList<Integer> selectionSortUnsorted = new ArrayList<Integer> (Arrays.asList(3,5,2,6,10));
		Utils util = new Utils();
		util.swap(selectionSortUnsorted, 1, 3);
		t.checkExpect(selectionSortUnsorted.get(1), 6);
		t.checkExpect(selectionSortUnsorted.get(3), 5);
		t.checkExpect(util.getMinIndex(selectionSortUnsorted, new CompareInts()), 2);
	}
	
	//Test for Merging two lists
	void testMergeLists(Tester t) {
		ArrayList<Integer> arr1 = new ArrayList<Integer> (Arrays.asList(2,3,5,8));
		ArrayList<Integer> arr2 = new ArrayList<Integer> (Arrays.asList(4,7,8,10));
		ArrayList<Integer> arr1Insert = new ArrayList<Integer> (Arrays.asList(2,3,4,5,8));
		ArrayList<Integer> arr3 = new ArrayList<Integer> (Arrays.asList(2,3,4,5,7,8,8,10));
		Utils util = new Utils();
		t.checkExpect(util.insert(4, arr1, new CompareInts()), arr1Insert);}
//		t.checkExpect(util.mergeLists(arr1, arr2, new CompareInts()), arr3);}
	
	
	
	
	
}



















